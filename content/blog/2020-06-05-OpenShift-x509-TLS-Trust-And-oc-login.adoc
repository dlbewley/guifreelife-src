---
banner: /images/browser-cert-ingress.png
---

= x509-TLS-Trust-And-oc-login

This post will hopefully solve two or three problems for you.

1. Why do I see _"error: x509 certificate signed by unknown authority error"_ when logging into OpenShift with `oc login`?
2. How can I trust the wildcard apps certificate used by my OpenShift ingress router?
3. I don't grok TLS certificates.

== Problem: oc login returns x509 certificate signed by unknown authority

Have you had this happen when logging in with `oc` or `kubectl`?

[source,sh]
----
$ oc login -u $OCP_USERNAME -p $OCP_PASSWORD $OCP_SERVER
error: x509: certificate signed by unknown authority
----

Then you thought "Oh, I know what to do!"

[source,sh]
----
$ oc login --kubeconfig=kubeconfig -u $OCP_USERNAME -p $OCP_PASSWORD --insecure-skip-tls-verify=true $OCP_SERVER
error: x509: certificate signed by unknown authority # Whaaa?!
----

Then realized, you are already logged in somehow!

[source,sh]
----
$ oc whoami                         
system:admin
----

What the heck is going on?

What does _"certificate signed by unknown authority"_ this mean? It means your client does not trust the issuer (Certificate Authority) for a encypted endpoint involved in the login process. But there is a cert right there in the _kubeconfig_ you say? And what endpoints are involved? And what is a certificate authority anyway? Let's dig into that.

.**TLDR**
[TIP]
Logging in as _system:admin_ uses a client certicate for auth and hits only _api.<cluster>.<domain>_ which is trusted, but logging in as a user with a password hits the OAuth route at _oauth-openshift-oauth.apps.<cluster>.<domain>_ which is not.

== X.509 Background

First a little https://www.ssl.com/faqs/what-is-an-x-509-certificate/[background on X.509 certificates] and what "unknown authority" error means.

Any service using Transport Layer Secuiry encryption has a private key and a public certificate component. If data is encrypted using the public certificate, it can not be read without the private key. But how you know your client is encoding data for the public certificate of the service you are talking to and not a bad actor inserted in the data path?

If you access a site that has a certificate issued (signed) by an authority you do not recognize or trust then you can have no certainty that your data is not being easves dropped upon.

If the public certificate has a signature which you can verify then you can be sure of the provinance of the certificate. Most public web sites will have their certificates signed (issued) by a well known public https://en.wikipedia.org/wiki/Certificate_authority[certificate authority] like DigiCert or perhaps https://en.wikipedia.org/wiki/Let%27s_Encrypt[Let's Encrypt].

_Why?_ Because most people already trust signatures written by these authorities.
_How?_ Because their public keys were already transfered to your computer using a secure mechanism such as bundling with your operating system or with your browser.

=== Google Example

First let's look at the certificate for google.com. Notice it has a subject common name of `*.google.com` indicating it is a wildcard certificate. You can see it was issued by `GTS CA 101`. Additionally you can see the certificate will only remain valid for a period of 3 months.

[source,sh]
----
$ echo | openssl s_client -connect google.com:443 | openssl x509 -subject -issuer -dates -noout
depth=2 OU = GlobalSign Root CA - R2, O = GlobalSign, CN = GlobalSign
verify return:1
depth=1 C = US, O = Google Trust Services, CN = GTS CA 1O1
verify return:1
depth=0 C = US, ST = California, L = Mountain View, O = Google LLC, CN = *.google.com
verify return:1
DONE
subject= /C=US/ST=California/L=Mountain View/O=Google LLC/CN=*.google.com
issuer= /C=US/O=Google Trust Services/CN=GTS CA 1O1
notBefore=May 20 11:48:05 2020 GMT
notAfter=Aug 12 11:48:05 2020 GMT
----

Look a little closer and you can see more than one certificate is presented when you access the site. 
In this chain you can see there is certificate 0 and certificate 1. Each certificate has a subject `s` (who it represents) and an issuer `i` (who vouched for it).

In this example we trust the `*.google.com` certificate because we trust the `GTS CA 101`, and we trust that because we trust `GlobalSign`.

The GTS CA 101 certificate is known as an intermediate certificate. You typically don't trust those directly. This is signed by the last certificate in this chain known as the root certificate. But there are only 2 shown below you say?

[source,sh]
----
$ echo | openssl s_client -connect google.com:443 | head           
depth=2 OU = GlobalSign Root CA - R2, O = GlobalSign, CN = GlobalSign
verify return:1
depth=1 C = US, O = Google Trust Services, CN = GTS CA 1O1
verify return:1
depth=0 C = US, ST = California, L = Mountain View, O = Google LLC, CN = *.google.com
verify return:1
DONE
CONNECTED(00000003)
---
Certificate chain
 0 s:/C=US/ST=California/L=Mountain View/O=Google LLC/CN=*.google.com
   i:/C=US/O=Google Trust Services/CN=GTS CA 1O1
 1 s:/C=US/O=Google Trust Services/CN=GTS CA 1O1
   i:/OU=GlobalSign Root CA - R2/O=GlobalSign/CN=GlobalSign
---
Server certificate
-----BEGIN CERTIFICATE-----
----

The root certificate is not presented by the web server because you (hopefully) already have it on your computer and have tacitely agreed to trust it by way of your operating systems public key infrastructure.

This is the crux of our problem. The OpenShift cluster has more than one certificate authority which is issuing certificates for multiple services. This seperation allows for enhance security. Fortunately the OpenShift installer securely copied out the CA cert that was used to sign the API endpoint certificate. Wasn't that enough?

=== Cluster Example

Let's take a look at our API endpoint in the same way.

.https://en.wikipedia.org/wiki/Server_Name_Indication[Server Name Identification] (vhosts for tls) is in use
[IMPORTANT]
Note that we have to provide the virtualhost name via the `-servername` argument to ensure we are talking to the right service and viewing the right certificate.

[source,sh]
----
$ echo | openssl s_client -connect api.aws-quick.aws.tofu.org:6443 -servername api.aws-quick.aws.tofu.org | head
depth=1 OU = openshift, CN = kube-apiserver-lb-signer
verify error:num=19:self signed certificate in certificate chain
verify return:0
DONE
CONNECTED(00000006)
---
Certificate chain
 0 s:/CN=api.aws-quick.aws.tofu.org
   i:/OU=openshift/CN=kube-apiserver-lb-signer
 1 s:/OU=openshift/CN=kube-apiserver-lb-signer
   i:/OU=openshift/CN=kube-apiserver-lb-signer
---
Server certificate
-----BEGIN CERTIFICATE-----
----

You can also view this chain of 2 certificates in the browser by clicking the padlock icon in the location bar.

image::/images/browser-cert-api.png[browser-cert-api at api.cluster]

It looks like our API certificate is issued by _kube-apiserver-lb-signer_ CA, and it's a sure bet your operating system doesn't know anything about this certificate authority yet. 

The _kube-apiserver-lb-signer_ CA cert was not installed with our browser or operating system and it didn't even exist until the cluster was installed and it was not signed by any trusted authority that makes it a root certificate authority.

== Certificate use in OpenShift

I'm not going to plumb the depths of all uses of TLS in OpenShift which is of course used to ensure secure communication and identification throughout. But it turns out that even logging in interacts with more than one certificate authority.

=== The Post-Installation kubeconfig

When installing Openshift you should have https://github.com/dlbewley/homelab/blob/master/bin/ocp[collected a client config] file from `install-dir/auth/kubeconfig` which contains the CA certificate for "the cluster", and a client certificate for `system:admin` user which enables a login with no password require. Additionally `install-dir/auth/kubeadmin-password` contains the password for the `kubeadmin` user in the web console.

This _kubeconfig_ file includes `base64` encoded values of multiple X.509 certificates. The Certificate Authority certificate for the cluster API endpoint is within _certificate-authority-data_. The admin user certiicate and private key are also visible in the user dictionary. Spoiler alert, there may be more than just those!

.The kubeconfig looks something like this:
[source,yaml]
----
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: LS0tL.<snip>.Qo=
    server: https://api.aws-quick.aws.tofu.org:6443
  name: quick
contexts:
- context:
    cluster: quick
    user: admin
  name: admin
current-context: admin
kind: Config
preferences: {}
users:
- name: admin
  user:
    client-certificate-data: LS0tL.<snip>.Qo=
    client-key-data: LS0tL.<snip>.g==
----

Let's extract these certificates and find the Certificate Authority for the API endpoint. Remember, we discovered above it should have a common name of _kube-apiserver-lb-signer_. 

[source,sh]
----
# convert kubeconfig from yaml to json
$ cat kubeconfig | yq r -j - | jq -s > kubeconfig.json
# pull the value from /clusters/cluster/certificate-authority-data
# and decode it
$ cat kubeconfig.json \
  | jq -r '.[].clusters[0].cluster."certificate-authority-data"' \
  | base64 -d > kubeconfig-ca-data.pem
----

It turns out there are 3 certificates in the kubeconfig certificate-authority-data! We only care about one at the moment.

[source,sh]
----
$ grep BEGIN kubeconfig-ca-data.pem
-----BEGIN CERTIFICATE-----
-----BEGIN CERTIFICATE-----
-----BEGIN CERTIFICATE-----
----

Because there are 3 certs in one file we have to get a little fancy and convert the file to an intermediary pkcs7 format. Otherwise we could seperate them each out into 3 files.

[source,sh]
----
$ openssl crl2pkcs7 -nocrl -certfile kubeconfig-ca-data.pem | openssl pkcs7 -print_certs -noout
subject=/OU=openshift/CN=kube-apiserver-localhost-signer
issuer=/OU=openshift/CN=kube-apiserver-localhost-signer

subject=/OU=openshift/CN=kube-apiserver-service-network-signer
issuer=/OU=openshift/CN=kube-apiserver-service-network-signer

subject=/OU=openshift/CN=kube-apiserver-lb-signer
issuer=/OU=openshift/CN=kube-apiserver-lb-signer
----

Let's reproduce the verification failure with `curl`.

[source,sh]
----
$ curl -I https://api.aws-quick.aws.tofu.org:6443
curl: (60) SSL certificate problem: self signed certificate in certificate chain
More details here: https://curl.haxx.se/docs/sslcerts.html

curl failed to verify the legitimacy of the server and therefore could not
establish a secure connection to it. To learn more about this situation and
how to fix it, please visit the web page mentioned above.
----

Now let's prove verification works with the cert(s) certificate-authority-data from kubeconfig.

[source,sh]
----
$ curl --cacert kubeconfig-ca-data.pem -I https://api.aws-quick.aws.tofu.org:6443
HTTP/2 403 
audit-id: a5ab2f62-c1a0-4bda-b992-4531587ce9b5
content-type: application/json
x-content-type-options: nosniff
content-length: 234
date: Sat, 06 Jun 2020 22:13:31 GMT
----

It worked! I hope you weren't surprised.

While it isn't totally relevant, let's take a peek at the admin client certificate and see who issued it.

[source,sh]
----
$ cat kubeconfig \
  | yq r -j - \
  | jq -r '.users[0].user."client-certificate-data"' \
  | base64 -d \
  | openssl x509 -noout -subject -issuer -dates
subject= /O=system:masters/CN=system:admin
issuer= /OU=openshift/CN=admin-kubeconfig-signer
notBefore=Jun  6 17:24:35 2020 GMT
notAfter=Jun  4 17:24:35 2030 GMT
----

This demonstrates yet another CA called _admin-kubeconfig-signer_, but we can ignore that for ow.

=== Pump up the logs

Well, it looks like we have the right CA cert in kubeconfig, so what is the problem?!

If you turn up the loglevel on the oc login command and you will find that the API is sending you over to the OAuth service to be verified and to receive a token.

Oh shoot! It looks like OAuth is using a certificate authority we don't know about.

[source,sh]
----
$ oc login -u $OCP_USERNAME -p $OCP_PASSWORD $OCP_SERVER --loglevel=6
I0605 17:17:14.214152   31550 loader.go:375] Config loaded from file:  /keybase/private/dlbewley/credz/ocp/bewley/kubeconfig
I0605 17:17:14.241262   31550 round_trippers.go:443] HEAD https://api.os.bewley.net:6443/ 403 Forbidden in 23 milliseconds
I0605 17:17:14.241467   31550 request_token.go:86] GSSAPI Enabled
I0605 17:17:14.244353   31550 round_trippers.go:443] GET https://api.os.bewley.net:6443/.well-known/oauth-authorization-server 200 OK in 2 milliseconds
I0605 17:17:14.314929   31550 round_trippers.go:443] HEAD https://oauth-openshift.apps.os.bewley.net  in 69 milliseconds
I0605 17:17:14.314952   31550 request_token.go:438] falling back to kubeconfig CA due to possible x509 error: x509: certificate signed by unknown authority
I0605 17:17:14.326346   31550 round_trippers.go:443] GET https://oauth-openshift.apps.os.bewley.net/oauth/authorize?client_id=openshift-challenging-client&code_challenge=0jD-xcHh1bdlFjcUgZWzLMs_rsIuRp1EFy49BeCC8Lg&code_challenge_method=S256&redirect_uri=https%3A%2F%2Foauth-openshift.apps.os.bewley.net%2Foauth%2Ftoken%2Fimplicit&response_type=code  in 11 milliseconds
I0605 17:17:14.331921   31550 round_trippers.go:443] GET https://api.os.bewley.net:6443/api/v1/namespaces/openshift/configmaps/motd 403 Forbidden in 3 milliseconds
F0605 17:17:14.494125   31550 helpers.go:114] error: x509: certificate signed by unknown authority
----

Without using `oc` here is how to do the same.

[source,sh]
----
$ curl -sk https://api.aws-quick.aws.tofu.org:6443/.well-known/oauth-authorization-server | jq .authorization_endpoint
"https://oauth-openshift.apps.aws-quick.aws.tofu.org/oauth/authorize"
$ curl --cacert kubeconfig-ca-data.pem  https://oauth-openshift.apps.aws-quick.aws.tofu.org/
curl: (60) SSL certificate problem: self signed certificate in certificate chain
----

=== TLS CA for the Oauth and Apps Endpoint

So what authority issued that certificate?

You can use openssl again or you can just browse to `https://oauth-openshift.apps.<cluster>.<domain>` and look at the certificate to see that the CA for the oauth route is _ingress-operator@<serialnumber>_.

In fact this is the same wildcard certificate used by default on all the application routes.

image::/images/browser-cert-ingress.png[browser-cert-ingress at oauth.apps.cluster]

**So how can we get the ingress-operator@<serialnumber> CA cert?**

.**Todo**
[IMPORTANT]
Better retrieval of CA cert and treatment of non-default setup.

* Where the cert is mounted

[source,sh]
oc rsh -n openshift-authentication deployment/oauth-openshift cat /run/secrets/kubernetes.io/serviceaccount/ca.crt

* Service account has secret associated

[source,sh]
oc get sa -n openshift-authentication oauth-openshift -o yaml

[source,sh]
----
$ oc extract secret/v4-0-config-system-router-certs -n openshift-authentication \
   --to - 2>/dev/null >router-cacert.pem
----

* Notice this contains 2 certs and a key. We want to protect that key, so we should not have even extracted it! 

[source,sh]
----
$ grep BEGIN router-cacert.pem
-----BEGIN CERTIFICATE-----
-----BEGIN CERTIFICATE-----
-----BEGIN RSA PRIVATE KEY-----

$ openssl crl2pkcs7 -nocrl -certfile router-cacert.pem | openssl pkcs7 -print_certs -noout
subject=/CN=*.apps.aws-quick.aws.tofu.org
issuer=/CN=ingress-operator@1591466269

subject=/CN=ingress-operator@1591466269
issuer=/CN=ingress-operator@1591466269
----

* Prove this CA lets us trust the OAuth endpoing

[source,sh]
----
$ curl -I --cacert router-cacert.pem  https://oauth-openshift.apps.aws-quick.aws.tofu.org/
HTTP/1.1 403 Forbidden
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Content-Type: application/json
Expires: 0
Pragma: no-cache
Referrer-Policy: strict-origin-when-cross-origin
X-Content-Type-Options: nosniff
X-Dns-Prefetch-Control: off
X-Frame-Options: DENY
X-Xss-Protection: 1; mode=block
Date: Sun, 07 Jun 2020 16:50:07 GMT
Content-Length: 234
----

Now, if you add the ingress CA

[source,sh]
$ oc --kubeconfig=kubeconfig login -u $OCP_USERNAME -p $OCP_PASSWORD --certificate-authority=router-cacert.pem
The server uses a certificate signed by an unknown authority.
You can bypass the certificate check, but any data you send to the server could be intercepted by others.
Use insecure connections? (y/n): y
oc --kubeconfig=kubeconfig whoami
kube:admin

== Fix TLS Trust on Mac OSX

Now that we have the CA certs let's install them so our browser, `curl`, and `oc` will trust them to verify our cluster resources.

=== Install and Trust Certificate Authorities

How do we get that to be trusted automatically?

**Instructions for Mac OS X Catalina**

* Divide the kubeconfig-ca-data.pem file into 3 files. Call them kube-1.crt kube-2.crt kube-3.crt each including an individual certificate.

.**Examine certificate contents**
[TIP]
====
Use `openssl` to read some attributes of the certificate for confirmation of the contents.

[source,sh]
----
$ openssl x509 -in kube-3.crt -noout -subject -issuer -dates -serial
subject= /OU=openshift/CN=kube-apiserver-lb-signer
issuer= /OU=openshift/CN=kube-apiserver-lb-signer
notBefore=Jun  6 17:24:36 2020 GMT
notAfter=Jun  4 17:24:36 2030 GMT
serial=568603E86E655777
----
====

* Drag and drop each file onto the Keychain application or use `open kube-1.crt` on the command line and import them into the _"login"_ keychain.

* In Keychain certificates, search for "kube", and double cick on the certificate _"kube-apiserver-lb-signer"_. Set the trust policy to _"Always Trust"_. Keychain may not redraw the icon correctly so refresh or click around to confirm the change. 

image::/images/keychain-untrusted-kubesigner.png[keychain trust kubeconfig ca data]

You can also trust the other certs but they aren't needed.

At this point you can restart your browser or use `curl` to confirm the API endpoint is trusted.

image::/images/browser-cert-api-trusted.png[browser trusts API cert]
[source,sh]
$ curl  -I https://api.aws-quick.aws.tofu.org:6443                                              
HTTP/2 403 
audit-id: 84c23628-fab5-4af9-8542-658e9c998ef3
content-type: application/json
x-content-type-options: nosniff
content-length: 234
date: Sun, 07 Jun 2020 21:06:11 GMT

**Now the Ingress**

image::/images/keychain-import.png[keychain import router certs]

Doublelick on ingress-operator
  https://www.dropbox.com/s/nio7aaidjre6kmh/Screenshot%202020-06-05%2013.42.37.png?dl=0

image::/images/keychain-ingress-cert.png[keychain eval ingress cert]

Change _When using this certificate_ from _Use System Defaults_ to _Always Trust_
https://www.dropbox.com/s/azolm111dax2n3z/Screenshot%202020-06-05%2013.43.00.png?dl=0  

image::/images/keychain-trust-cert.png[keychain trust ingress cert]

And now 
oc --kubeconfig=kubeconfig login -u $OCP_USERNAME -p $OCP_PASSWORD
works and there is no need to pass in the cert and if you restart your browser then your apps will be trusted as well.



https://www.dropbox.com/s/av4k3xfgg4k8pyp/Screenshot%202020-06-05%2014.20.54.png?dl=0

image::/images/keychain-trusted-cert.png[keychain trusted ingress cert]

Need to redo this without importing the wildcard cert. It is not needed.

Credit to https://access.redhat.com/solutions/4505101